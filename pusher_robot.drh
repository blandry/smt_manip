#define epsilon 0.00001
#define c 0.0001

#define rox1_0 -0.5
#define roy1_0 0.0
#define rox2_0 0.0
#define roy2_0 -0.5

#define rox1 (cos(theta)*rox1_0 - sin(theta)*roy1_0)
#define roy1 (sin(theta)*rox1_0 + cos(theta)*roy1_0)
#define rox2 (cos(theta)*rox2_0 - sin(theta)*roy2_0)
#define roy2 (sin(theta)*rox2_0 + cos(theta)*roy2_0)

[0, 10] time;

// object
[-5, 5] x;
[-5, 5] y;
[-20, 20] theta;

// contact points for pushing
[-10, 10] vpx;
[-10, 10] vpy;

// stationary
{ mode 1;
  invt:
  flow:
    d/dt[x] = 0;
    d/dt[y] = 0;
    d/dt[theta] = 0;
    d/dt[vpx] = 0;
    d/dt[vpy] = 0;
  jump:
    (true) ==> @2 (and (x' = x) (y' = y) (theta' = theta) (vpx' <= 10) (vpy' <= 10));
    (true) ==> @3 (and (x' = x) (y' = y) (theta' = theta) (vpx' <= 10) (vpy' <= 10));
}

// push on surface 1
{ mode 2;
  invt:
    (rox1*vpx+roy1*vpy)^2 >= 0.5*((rox1^2+roy1^2)*(vpx^2+vpy^2));
  flow:
    d/dt[x] = ((c^2 + rox1^2)*vpx + rox1*roy1*vpy)/(c^2 + rox1^2 + roy1^2);
    d/dt[y] = (rox1*roy1*vpx + (c^2 + roy1^2)*vpy)/(c^2 + rox1^2 + roy1^2);
    d/dt[theta] = (rox1*((rox1*roy1*vpx + (c^2 + roy1^2)*vpy)/(c^2 + rox1^2 + roy1^2)) - roy1*(((c^2 + rox1^2)*vpx + rox1*roy1*vpy)/(c^2 + rox1^2 + roy1^2))) / c^2;
    d/dt[vpx] = 0;
    d/dt[vpy] = 0;
  jump:
    (true) ==> @1 (and (x' = x) (y' = y) (theta' = theta) (vpx' = 0) (vpy' = 0));
    (true) ==> @2 (and (x' = x) (y' = y) (theta' = theta) (vpx' <= 10) (vpy' <= 10));
}

// push on surface 2
{ mode 3;
  invt:
    (rox2*vpx+roy2*vpy)^2 >= 0.5*((rox2^2+roy2^2)*(vpx^2+vpy^2));
  flow:
    d/dt[x] = ((c^2 + rox2^2)*vpx + rox2*roy1*vpy)/(c^2 + rox2^2 + roy2^2);
    d/dt[y] = (rox2*roy2*vpx + (c^2 + roy2^2)*vpy)/(c^2 + rox2^2 + roy2^2);
    d/dt[theta] = (rox2*((rox2*roy2*vpx + (c^2 + roy2^2)*vpy)/(c^2 + rox2^2 + roy2^2)) - roy2*(((c^2 + rox2^2)*vpx + rox2*roy2*vpy)/(c^2 + rox2^2 + roy2^2))) / c^2;
    d/dt[vpx] = 0;
    d/dt[vpy] = 0;
  jump:
    (true) ==> @1 (and (x' = x) (y' = y) (theta' = theta) (vpx' = 0) (vpy' = 0));
    (true) ==> @3 (and (x' = x) (y' = y) (theta' = theta) (vpx' <= 10) (vpy' <= 10));
}

init:
@1	(and (x = 0) (y = 0) (theta = 0));

goal:
@1	(and (x > 1) (y > 1));
